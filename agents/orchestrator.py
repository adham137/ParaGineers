import json
import time
import os
from agents.omp_expert import OMPSExpert
from agents.mpi_expert import MPIExpert
from agents.checker import Checker
from config import Config
from utils import Logger, LogColors # Import Logger

AGENT_NAME = "Orchestrator"
MAX_RETRIES = Config.MAX_RETRIES

class Orchestrator:
    def __init__(self):
        Logger.info("Orchestrator initialized. Initializing sub-agents...", AGENT_NAME, LogColors.ORCHESTRATOR)
        self.omp = OMPSExpert()
        self.mpi = MPIExpert()
        self.checker = Checker()
        Logger.info("All sub-agents initialized.", AGENT_NAME, LogColors.ORCHESTRATOR)

    def choose_expert(self, code: str):
        if "MPI_" in code.upper(): # Check for MPI keywords
            Logger.info("MPI keyword detected in code, choosing MPIExpert.", AGENT_NAME, LogColors.ORCHESTRATOR)
            return self.mpi
        else:
            Logger.info("Defaulting to OMPExpert.", AGENT_NAME, LogColors.ORCHESTRATOR)
            return self.omp

    def run(self, source_path: str):
        Logger.info(f"Starting parallelization run for source file: {source_path}", AGENT_NAME, LogColors.ORCHESTRATOR)
        try:
            with open(source_path, 'r') as f:
                original_code = f.read()
            Logger.info(f"Successfully read source code from {source_path}", AGENT_NAME, LogColors.ORCHESTRATOR)
        except FileNotFoundError:
            Logger.error(f"Source file not found: {source_path}", AGENT_NAME)
            raise
        except IOError as e:
            Logger.error(f"Error reading source file {source_path}: {e}", AGENT_NAME)
            raise

        context_id = f"run-{int(time.time())}"
        Logger.info(f"Generated Context ID: {context_id}", AGENT_NAME, LogColors.ORCHESTRATOR)

        expert = self.choose_expert(original_code)
        expert_name = "OMPExpert" if expert == self.omp else "MPIExpert"
        Logger.info(f"Chosen expert: {expert_name}", AGENT_NAME, LogColors.ORCHESTRATOR)

        current_code_to_process = original_code
        
        # Initial message for the first processing attempt
        mcp_msg_to_expert = {
            "agent_id": AGENT_NAME,
            "context_id": context_id,
            "payload": {"code": current_code_to_process}, 
            "metadata": {"use_openmp": expert == self.omp, "retry_attempt": 0}
        }

        for attempt in range(MAX_RETRIES + 1): # MAX_RETRIES for refine, so MAX_RETRIES+1 total attempts including initial
            Logger.info(f"--- Attempt {attempt + 1} of {MAX_RETRIES + 1} (Retry {attempt} of {MAX_RETRIES}) ---", AGENT_NAME, LogColors.ORCHESTRATOR)
            
            if attempt == 0: # Initial processing call
                Logger.info(f"Calling {expert_name}.process...", AGENT_NAME, LogColors.ORCHESTRATOR)
                
                processed_msg_from_expert = expert.process(mcp_msg_to_expert)
            else: # Refinement call
                Logger.info(f"Calling {expert_name}.refine...", AGENT_NAME, LogColors.ORCHESTRATOR)
                
                
                processed_msg_from_expert = expert.refine(mcp_msg_to_expert)

            current_attempted_code = processed_msg_from_expert["payload"]["code"]
            metadata_from_expert = processed_msg_from_expert["metadata"]

            Logger.info("Attempting to compile the code generated by the expert.", AGENT_NAME, LogColors.ORCHESTRATOR)
            success, errors = self.checker.compile(
                code=current_attempted_code,
                use_openmp=metadata_from_expert.get("use_openmp", expert == self.omp), # Get from metadata or re-evaluate
                src_dir=os.path.dirname(source_path) # Ensure src_dir is passed
            )

            if success:
                Logger.success("âœ… Compilation succeeded!", AGENT_NAME)
                return current_attempted_code
            else:
                Logger.warning(f"Compilation failed on attempt {attempt + 1}.", AGENT_NAME)
                Logger.error(f"Compilation errors: {errors}", AGENT_NAME)
                if attempt >= MAX_RETRIES:
                    Logger.error("Maximum retry attempts reached. Parallelization failed.", AGENT_NAME)
                    raise RuntimeError(f"Failed to parallelize and compile after {MAX_RETRIES + 1} attempts. Last errors:\n{errors}")

                # Prepare message for the next refinement iteration
                mcp_msg_to_expert = {
                    "agent_id": AGENT_NAME,
                    "context_id": context_id,
                    "payload": {
                        "code": current_attempted_code,
                        "original_code": original_code,
                        "errors": errors
                    },
                    "metadata": {
                        "use_openmp": metadata_from_expert.get("use_openmp", expert == self.omp),
                        "retry_attempt": attempt + 1
                    }
                }
        # Should not be reached if MAX_RETRIES is handled correctly in loop
        raise RuntimeError("Failed after configured retries.")